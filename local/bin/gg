#!/usr/bin/env ruby

require 'shellwords'
require 'set'
require 'open3'

# A curated list of git-grep options that take arguments (so we can avoid
# treating the option argument as a gg argument).
OPTS_WITH_ARGS = Set.new [
  '--max-depth', '-C', '--context', '-A', '--after-context', '-B',
  '--before-context', '-f'
]

def usage(status)
  puts <<-EOT
Usage:
  gg --raw GITGREP_OPT...
  gg [GITGREP_OPT...] EXTENSIONS PATTERN [--] [PATH...]

Description:
  Each GITGREP_OPT is passed through to git-grep unmodified. EXTENSIONS is a
  comma-separated list of extensions files must match against before being
  searched through (e.g. html,css or 'all' or 'any' to match any extension,
  including no extension).
  EOT
  exit status
end

def main
  argv = ARGV.dup

  if argv.empty? || argv.any? {|a| ['-h', '--help'].include?(a)}
    usage(1)
  end

  # Only force colors if the output is a terminal
  color = STDOUT.tty? ? '--color=always' : ''

  # For --raw, do minimal processing and exit early.
  if argv.delete('--raw')
    gitgrep_args = argv
    gitgrep_cmd = build_command(['git', 'grep', color, gitgrep_args])
    statuses = Open3.pipeline(gitgrep_cmd, 'squelch')
    error_status = statuses.find {|s| !s.success?}
    exit error_status ? error_status.exitstatus : 0
  end

  # Treat everything after '--' as an argument no matter what it looks like.
  sep_index = argv.rindex('--')
  if !sep_index.nil?
    explicit_args = argv.slice!(sep_index, argv.length)
    explicit_args.shift # throw away the '--'
  else
    explicit_args = []
  end

  # Some git-grep options take an argument, so we try to recognize those and
  # skip the argument in order to avoid treating it as an extension specifier.
  last_opt_index = argv.rindex {|arg| arg.start_with?('-')}
  if !last_opt_index.nil?
    last_opt = argv[last_opt_index]
    arg_start = last_opt_index + (OPTS_WITH_ARGS.include?(last_opt) ? 2 : 1)
    gg_args = argv.slice!(arg_start, argv.length)
  else
    # Use slice! to transfer gg args to 'gg_args', leaving argv empty.
    gg_args = argv.slice!(0, argv.length)
  end
  gg_args += explicit_args

  # Everything between 'gg' and the extensions specifier is a git-grep option
  # passed through unmodified.
  gitgrep_args = argv

  if gg_args.empty?
    warn "no extensions specifier or pattern given"
    usage 1
  elsif gg_args.length == 1
    warn "no extensions specifier given (use 'all' to match all extensions)"
    usage 1
  end

  type_str, pattern, *pathspecs = gg_args

  if pathspecs.empty?
    pathspecs << '.'
  end

  # If narrowing results by extension, expand each pathspec to match any of the
  # specified extensions.
  unless ['all', 'any'].include?(type_str)
    types = type_str.split(',')
    pathspecs = pathspecs.flat_map do |path|
      types.map { |type| "#{path.chomp('/')}/*.#{type}" }
    end
  end

  squelch_s, status = Open3.capture2('squelch', '--list-git')
  pathspecs += squelch_s.each_line.map {|l| l.chomp}

  cmd = build_command(['git', 'grep', '-In', '--no-index', color, gitgrep_args,
         '-e', pattern, '--', pathspecs])

  exec(*cmd)
end

def build_command(cmd)
  cmd.flatten.reject { |a| a.empty? }
end

main
